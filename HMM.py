#!/usr/bin/env python
# Developed by Chiheb Chebbi 2017


"""
@author:       Chiheb Chebbi
@license:      GNU General Public License 2.0
@contact:      chiheb.chebbi@tek-up.de
@Description:  Analyses Linux Malware by performing static, dynamic and memory analysis
"""

import os
import sys
import time
import yara
import hashlib 
import time
import requests
import json
#import yara
import socket
from termcolor  import colored
from optparse import OptionParser
from sklearn.neighbors.kde import KernelDensity
import numpy as np
import matplotlib.pyplot as plt
from numpy import linspace,hstack
from scipy.stats.kde import gaussian_kde
from scipy.stats import norm
from numpy import linspace,hstack
import matplotlib.pyplot as mp
import sys
import ast
import subprocess
import glob
from os import path
import xml.etree.ElementTree as xml


banner = """
 
                        Linux Malware Analysis Sandbox 1.0-beta
                             Developed by Chiheb Chebbi

"""

print colored(banner,"blue")

#print colored("Usage:Command [options] <file> [arguments]","red")


#Option verification
if len(sys.argv) <=1:
	print colored("Please Enter a valid option to start the Malware Analysis Or Type --help ","red")
	sys.exit()



parser = OptionParser('Usage: Command [Options] <file> [args]')

#parser.add_option("-h", "--help", action="store_true", dest="help", help = "Dispaly Help Message",  default=False)
parser.add_option("-d", "--dynamic", action="store_true", dest="dynamic", help="Dynamic Malware Analysis",  default=False)
parser.add_option("-s", "--static", action="store_true", dest="static", help = "Static Malware Analysis",  default=False)
parser.add_option("-v", "--version", action="store_true", dest="version", help="Display the version of this application",  default=False)
parser.add_option("-m", "--memory", action="store_true", dest="memory", help="Full Memory Forensics",  default=False)

(options, args) = parser.parse_args()

#help = options.help
static = options.static
dynamic = options.dynamic
memory = options.memory
version = options.version

#Post Request for Malware Scanning

params = {'apikey': '3a6eb41041b884c803b1a06ab24e6bb652a30e8634e1db0156693961f539d1cc'}
files = {'file': ('elf', open('elf', 'rb'))}
response = requests.post('https://www.virustotal.com/vtapi/v2/file/scan', files=files, params=params)
json_response = response.json()
#print(json_response["permalink"])
#print(json_response["scan_id"])

#Retrieve Report - Get Request 

params = {'apikey': '3a6eb41041b884c803b1a06ab24e6bb652a30e8634e1db0156693961f539d1cc', 'resource': '7657fcb7d772448a6d8504e4b20168b8'}
headers = {
  "Accept-Encoding": "gzip, deflate",
  "User-Agent" : "gzip,  Malware Analysis Sandbox requests"
  }
response1 = requests.get('https://www.virustotal.com/vtapi/v2/file/report',
  params=params, headers=headers)
json_response1 = response1.json()





#if help:
#	print("Display Help Message")

if static:

	bannerStatic = """


	 -------------------------------------------------------
	 |                      Static Analysis                |
	 -------------------------------------------------------
	"""


	print bannerStatic
	print colored("[OK]","green"),"Static Malware Analysis"
	print colored("[OK]","green"),"Starting Information Gathering about the File ..."
	print colored("[OK] File Information","yellow")
	os.system("file elf")
#MD5 Hash
	print colored("[OK] MD5 Hash","yellow")
	print(hashlib.md5(open('elf','rb').read()).hexdigest())

#fuzzy hash(ssdeep hash)
	print colored("[OK] Fuzzy Hash","yellow")
	os.system("ssdeep elf")

#Strings (Uncomment Later)
	#print colored("[OK]Strings","yellow")
	#os.system("strings elf")
#ELF Headers Information
	print colored("[OK] ELF Headers:","yellow")
	os.system("readelf -h  elf")
#Dependencies of the Malware sample
	print colored("[OK] Malware Dependencies:","yellow")
	os.system(" ldd  elf")

#Online Scanning
        print colored("[OK] Malware Scanning:","yellow")
# Scanning Result
	print colored("Number of Antivirus scanners: "+ str(json_response1["total"]),"blue")
        print colored("Scan Date: "+ str(json_response1["scan_date"]),"blue")	
	print colored("Scan ID: "+ str(json_response1["scan_id"]),"blue")
# Live Scanner Results	(Uncomment Later)
	#print colored("Live Scanners: "+ str(json_response1["scans"]),"blue")





elif dynamic:

	bannerDynamic = """


	 -------------------------------------------------------
	 |                      Dynamic Analysis               |
	 -------------------------------------------------------
	"""


	print bannerDynamic
	print colored("[OK]","green"),"Dynamic Malware Analysis"
	print colored("[OK]","green"),"Collecting Network information and system behaviours ..."
	print "Dynamic Linux Malware Analysis"

	#Check Internet connexion 

	REMOTE_SERVER = "www.tek-up.de"
	def is_connected():
	  try:
	    # see if we can resolve the host name -- tells us if there is
	    # a DNS listening
	    host = socket.gethostbyname(REMOTE_SERVER)
	    # connect to the host -- tells us if the host is actually
	    # reachable
	    s = socket.create_connection((host, 80), 2)
	    return "Internet"
	  except:
	     pass
	     
	     print "[ OK ]cleaning Inetsim logs "
	     #os.remove("/home/ghost/Desktop/MalwareSandbox/elf")
	     print "[ OK ]starting inetsim"
	     #Loading: waiting for services to start 
	     """
	     for i in range(100):
	    	time.sleep(0.1)
	    	sys.stdout.write("\r%d%%" % i)
	    	sys.stdout.flush()

	     """
	     #os.system("sudo inetsim")
	     return "False  There is no internet " 
	     
	print is_connected()

	#starting capturing Network packets
	#os.system("sudo tcpdump -qn")


	
elif memory:


	bannerMemory = """


	 -------------------------------------------------------
	 |                      Memory Analysis                |
	 -------------------------------------------------------
	"""


	print bannerMemory
	print colored("[OK]","green"),"Memory Malware Analysis"
	print colored("[OK]","green"),"Collecting Memory Dumps ..."
	print "Memory Malware Analysis"


	#configure  the PATH and the Profile 
	#VolaPATH = "volatility --info " 
	#os.system(VolaPATH + "| grep linux")
	#os.system(VolaPATH + "| grep windows")




	#Path of the memory Dump 
	VMemDump = "ch2.dmp"

	# chose the profile of the memory dump in this case Win7SP1x86

	VProfile = "Win7SP1x86"


	#Process list
	print colored("[OK] Processes List" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " pslist")

	#Hidden or terminated Processes 
 	print colored("[OK] Processes List" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " psscan")

	print colored("[OK] Processes List" , "green")  
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " pstree")

	print colored("[OK] Processes List" , "green")  
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " psscan")

	print colored("[OK] DLL List" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " dlllist")

	print colored("[OK] Commands List" , "green")  
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " cmdline")

	print colored("[OK] SIDS" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " getsids")

	print colored("[OK] Commands history" , "green")  
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " cmdscan")

	print colored("[OK] Internet surfing History" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " iehistory")

	print colored("[OK] Network Activities" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " netscan")

	print colored("[OK] Processes List" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " modules")

	print colored("[OK] Processes List" , "green")  
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " callback")

	print colored("[OK] Callbacks" , "green") 
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " mutantscan")

	print colored("[OK] API Hooks" , "green")  
	os.system("volatility -f " + VMemDump + " --profile=" + VProfile + " apihooks")



	""" 
	
        #Linux Memory Analysis

	#configure  the PATH and the Profile 
	#VolaPATH = "volatility --info " 
	#os.system(VolaPATH + "| grep linux")
	
	print ("[ OK ] pslist")
	print ("[ OK ] pstree")
	print ("[ OK ] pidhashtable")
	print ("[ OK ] psaux")
	print ("[ OK ] psenv")
	print ("[ OK ] Threads")
	print ("[ OK ] pslist")
	print ("[ OK ] pstree")
	print ("[ OK ] pidhashtable")
	print ("[ OK ] psenv")
	print ("[ OK ] netstat")
	print ("[ OK ] Ifconfig")
	print ("[ OK ] TList_raw")
	print ("[ OK ] Library List")
	print ("[ OK ] Kernel Opened Files")

	#os.system(VolaPATH + "pslist")
	#os.system(VolaPATH + "pstree")
	#os.system(VolaPATH + "pidhashtable")
	#os.system(VolaPATH + "psaux")
	#os.system(VolaPATH + "psenv")
	#os.system(VolaPATH + "threads")
	#os.system(VolaPATH + "netstat")
	#os.system(VolaPATH + "ifconfig")
	#os.system(VolaPATH + "list_raw")
	#os.system(VolaPATH + "library_list")
	#os.system(VolaPATH + "kernel_opened_files") """


elif version:
	print("Linux Malware analysis Sandbox Beta Version 0.1 - Developed by Chiheb Chebbi")

text_file = open("align.fa", "w")
sys.stdout = text_file

data=open("seq.txt").readlines()
for n,line in enumerate(data):
	
	       data[n] =line.rstrip()
	
print >> text_file , ">./data/clusters/ADSPY/ADSPY_301/ADSPY-AdSpy-Gen_164c28065077a8e9746e40d5c659eb5f4eb1e307.beh  \n" + ''.join(data)


num_lines = sum(1 for line in open('outf.txt'))
print num_lines
 
#First file encoding
replacements = {
'running_process':'r',
'load_dll':'L',
'process_call':'P',
'get_system_directory':'s',
'open_key':'k',
'calltree':'c',
'thread':'t',
'load_image':'i',
'open_file':'o',
'enum_processes':'e',
'open_process':'O',
'vm_protect':'v',
'vm_write':'w',
'vm_allocate':'a',
'sleep':'Z',
'create_window':'y',
'recv_socket':'G',
'dump_line':'n',
'send_socket':'x',
'process':'p',
'create_socket':'C',
'connect_socket':'N',
'find_file':'f',
'get_computer_name':'T'
,'impersonate_user':'U',
'get_file_attributes':'g',
'query_value':'Q',
'set_value':'b',
'vm_mapviewofsection':'C',
'all_section':'A',
'create_mutex':'v',
'message':'m'
}

#Replace every behaviour by a letter Output.txt as Input and out.txt as Output

with open('Output.txt') as infile, open('out.txt', 'w') as outfile:
    for line in infile:
        for src, target in replacements.iteritems():
            line = line.replace(src, target)
        outfile.write(line)

#Second Encoding to Correct the First List

replacements2 = {
'p_call':'P',
'pes':'p',
'create_o':'o',
'create_p':'p',
'kill_p':'',
'create_t':'t',
'running_p':'r',
}

# out.txt as Input  and outf.txt as Output

with open('out.txt') as infile, open('outf.txt', 'w') as outfile:
    for line in infile:
        for src, target in replacements2.iteritems():
            line = line.replace(src, target)
        outfile.write(line)


X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])

val = val = ast.literal_eval(open(fp).read())
size = val[len(val) - 1]

kde = KernelDensity(kernel='gaussian', bandwidth=0.2).fit(X)

print (kde.score_samples(X))
plt.title("Kernel Density Estimation")
plt.plot(linspace(0,size,size*2),kde,'r')
plt.xlabel("Sequence length")
plt.ylabel("Probability density")

tree = xml.parse('0b8aef4d2de04dea51228e406270662035904866.LOOPER.xml')
root = tree.getroot()
text_file = open("Output.txt", "w")
sys.stdout = text_file

for elem in tree.iter():
	print >> text_file,elem.tag

text_file.close()  

y_true = [2, 0, 2, 2, 0, 1,3,7,5,8,9,8,1,0]
y_pred = [0, 0, 2, 2, 0, 2,5,4,2,0,2,5,8,2]

cm = confusion_matrix(y_true, y_pred)
cmap=plt.cm.Blues

fig = plt.figure()
ax = fig.add_subplot(111)
#cax = ax.matshow(cm)
#fig.colorbar(cax)
#plt.plot(cm)

plt.tight_layout()
plt.imshow(cm, interpolation='nearest', cmap=cmap)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()
print(classification_report(y_true, y_pred))

metrics=[]

f=open('outputhmm.txt')
line=f.readlines()
l1=line[17]
print l1 
metrics1 = list(l1.split())
for word in metrics1:
	print word

'''for  i in range(0,9):

	print metrics[i]'''
#metrics
print (metrics1)

l2=line[24]
metrics2 = list(l2.split())
for word2 in metrics2:
	print word2

print metrics2    
